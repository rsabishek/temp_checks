Sure, you can set the bearer token as a field of the `Client` struct and then add it as an `Authorization` header to your requests. 

Here's how you can modify the client to support bearer tokens:

```go
// api/client.go (modifications highlighted)

package api

// ... other imports ...

type Client struct {
	HTTPClient   *http.Client
	BearerToken  string // Add this field
}

func NewClient() *Client {
	return &Client{
		HTTPClient:  &http.Client{},
		BearerToken: "YOUR_HARD_CODED_TOKEN", // Set it here
	}
}

// Now, before making any HTTP request, add the token to the request headers:

func (c *Client) CreateOAuthClient(oc *OAuthClient) (*OAuthClient, error) {
	body, err := json.Marshal(oc)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", baseURL+"/path_to_create_endpoint", bytes.NewBuffer(body))
	if err != nil {
		return nil, err
	}

	req.Header.Set("Authorization", "Bearer "+c.BearerToken) // Set the token here
	req.Header.Set("Content-Type", "application/json")

	resp, err := c.HTTPClient.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	// ... rest of the function ...
}

// Apply similar modifications to ReadOAuthClient and other methods as well.
```

By adding the `BearerToken` field to your `Client` struct, you can easily set the bearer token and use it in all your API requests. Note that hardcoding tokens in production is not recommended for security reasons. This is just for your initial testing. In the future, consider a more dynamic way of setting and refreshing tokens.